= Using a thread pool for parallel resolvers

When you run Pathom in Clojure with the parallel connect, the resolver functions are
running inside core.async `go` blocks. In case of CLJS most IO is done async, making
this a non-issue, but if you are on the JVM and doing blocking IO, this means
the code is doing IO on `go` blocks, which is a no-no.

The best option is to switch to some library that performs async IO, but if you
can't or won't, Pathom provides a thread pool constructor and an option to inform 
the engine to run the resolvers on a thread pool to avoid blocking the `go` blocks.

Here is an example of how to setup a thread pool (clj only!):

[source,clojure]
----
(def parser
  (p/parallel-parser
    {::p/env     {::p/reader               [p/map-reader
                                            pc/parallel-reader
                                            pc/open-ident-reader
                                            p/env-placeholder-reader]
                  ; setup the thread pool
                  ::pc/thread-pool         (pc/create-thread-pool (async/chan 200))
                  ::p/placeholder-prefixes #{">"}}
     ::p/mutate  pc/mutate-async
     ::p/plugins [(pc/connect-plugin {::pc/register []})
                  p/error-handler-plugin
                  p/trace-plugin]}))
----
